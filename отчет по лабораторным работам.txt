 Отчет по лабораторной работе 1 вариант 5  "Расстояние Хэмминга"

Цель работы:

Реализация и практическое применение функции для расчета расстояния Хэмминга между двумя строками одинаковой длины с использованием языка программирования Python.

Задачи:

1. Разработать функцию hamming_distance(s, t), вычисляющую расстояние Хэмминга между двумя входными строками s и t.
2. Реализовать проверку на равенство длин строк перед вычислением расстояния. В случае неравенства длин строк, генерировать исключение ValueError.
3. Обеспечить обработку исключения ValueError при вызове функции.
4. Продемонстрировать работу функции с заданными входными строками и вывести результат.
Инструменты, Алгоритмы:
 Язык программирования: Python 3.x
Функция hamming_distance(s, t):
   Алгоритм вычисления расстояния Хэмминга основан на поэлементном сравнении двух строк.
   Входные данные: Две строки s и t одинаковой длины.
   Алгоритм:
    1. Проверка равенства длин строк s и t. Если длины не равны, генерируется исключение ValueError с информативным сообщением.
    2. Инициализация переменной distance значением 0. Эта переменная будет хранить значение расстояния Хэмминга.
    3. Использование цикла zip(s, t) для одновременной итерации по символам строк s и t.
    4. На каждой итерации цикла сравниваются текущие символы char_s и char_t.
    5. Если символы не равны (char_s != char_t), значение переменной distance увеличивается на 1.
    6. После завершения цикла возвращается значение переменной distance.
 Выходные данные: Целое число, представляющее расстояние Хэмминга между строками s и t.
 Исключение ValueError: Используется для обработки ситуации, когда входные строки имеют разную длину, что делает невозможным вычисление расстояния Хэмминга.
Функция zip(s, t): Встроенная функция Python, позволяющая итерироваться по двум или более последовательностям одновременно.

Ошибки и их исправления:
Во время разработки кода возникла следующая ошибка:
Некорректная обработка исключения ValueError: Первоначальная версия кода не содержала блока try...except для обработки исключения ValueError, которое могло быть сгенерировано функцией hamming_distance в случае, если входные строки имели разную длину. Это приводило к аварийному завершению программы с неинформативным сообщением об ошибке.

  Исправление: Добавлен блок try...except для обработки исключения ValueError. В блоке try вызывается функция hamming_distance. В блоке except перехватывается исключение ValueError и выводится сообщение об ошибке, содержащее информацию о причине возникновения исключения.

В ходе выполнения лабораторной работы была успешно разработана функция hamming_distance, вычисляющая расстояние Хэмминга между двумя строками одинаковой длины. Была реализована проверка на равенство длин строк перед вычислением расстояния, а также обработка исключения ValueError в случае неравенства длин строк. Полученный код демонстрирует корректную работу функции и обеспечивает информативный вывод результатов

Отчет по лабораторной работе 2 вариант 5  "Поиск вхождений подстроки"
Цель работы:
Разработка и практическое применение функции для поиска всех вхождений подстроки в строку с использованием языка программирования Python.
Задачи:

1. Реализовать функцию positionsall(s, t), находящую все индексы вхождений подстроки t в строку s.
2. Реализовать проверку длины входной строки s. В случае, если длина строки s равна 1000, программа выводит соответствующее сообщение. Если длина строки s больше 1000, программа предлагает ввести другую последовательность. Если длина строки s меньше 1000, программа выводит соответствующее сообщение.
3. Обеспечить корректное функционирование функции positionsall(s, t) для различных входных данных.
4. Продемонстрировать работу функции с заданной входной строкой и подстрокой и вывести результат.


Инструменты, Алгоритмы:

  Язык программирования: Python 3.x
  Функция positionsall(s, t):
  Алгоритм поиска вхождений подстроки основан на использовании встроенного метода find() для поиска следующего вхождения подстроки в строку, начиная с заданной позиции.
  Входные данные: Строка s и подстрока t.
  Алгоритм:
    1. Инициализация списка positions, который будет содержать индексы всех вхождений подстроки t в строку s.
    2. Инициализация переменной start значением 0. Эта переменная будет указывать на позицию, с которой начинается поиск следующего вхождения.
    3. Использование цикла while True для поиска всех вхождений подстроки.
    4. Внутри цикла используется метод s.find(t, start) для поиска первого вхождения подстроки t в строку s, начиная с позиции start. Результат поиска сохраняется в переменную index.
    5. Если index равен -1, это означает, что подстрока t больше не встречается в строке s, начиная с позиции start. В этом случае цикл завершается командой break.
    6. Если index не равен -1, это означает, что подстрока t найдена в строке s на позиции index. В этом случае значение index добавляется в список positions.
    7. Значение переменной start увеличивается на 1 (start = index + 1) для того, чтобы при следующем поиске не найти то же самое вхождение подстроки.
    8. После завершения цикла возвращается список positions, содержащий индексы всех вхождений подстроки t в строку s.
  Выходные данные: Список целых чисел, представляющих индексы всех вхождений подстроки t в строку s.

Ошибки и их исправления:
 Отсутствие проверки на длину строки s перед поиском вхождений подстроки. Первоначальная версия кода не содержала проверки на длину строки s, что могло привести к неоптимальной работе программы в случае, если длина строки s не соответствовала требованиям (например, если она была слишком длинной).

  Исправление: Добавлена проверка на длину строки s перед поиском вхождений подстроки. В случае, если длина строки s равна 1000, программа выводит соответствующее сообщение. Если длина строки s больше 1000, программа предлагает ввести другую последовательность. Если длина строки s меньше 1000, программа выводит соответствующее сообщение.


В ходе выполнения лабораторной работы была успешно разработана функция positionsall, находящая все индексы вхождений подстроки в строку. Добавлена проверка на длину входной строки s и вывод соответствующих сообщений. 


 Отчет по лабораторной работе 3 вариант 1  "Представление данных в Python"

Цель работы:

Освоить базовые приемы визуализации данных с использованием библиотек pandas, matplotlib и statsmodels в Python, включая построение диаграмм рассеяния и графиков временных рядов.

Задачи:

1. Построить диаграмму рассеяния для набора данных "Iris", отображающую взаимосвязь между длиной и шириной чашелистика (sepal length и sepal width) для различных классов ирисов.
2. Построить график временного ряда, отображающий изменение концентрации CO2 в атмосфере в период с 1958 по 1980 год, используя данные из пакета statsmodels.
3. Оформить полученные графики, добавив подписи к осям, заголовок, легенду (для диаграммы рассеяния) и сетку для улучшения читаемости.

Инструменты, Алгоритмы:

 Язык программирования: Python 3.x
 Библиотеки:
   pandas: Для работы с табличными данными (загрузка, фильтрация, обработка).
  matplotlib.pyplot: Для построения графиков.
  statsmodels.api: Для доступа к наборам данных, в частности, к данным о концентрации CO2.
 Алгоритмы:
   Построение диаграммы рассеяния:
    1. Загрузка данных из CSV-файла, расположенного по URL, в DataFrame pandas.
    2. Определение уникальных классов ирисов (setosa, versicolor, virginica) из столбца "class".
    3. Определение списка цветов для каждого класса.
    4. Итерация по классам, выборка подмножества данных, соответствующих текущему классу, и построение диаграммы рассеяния для этих данных с использованием функции plt.scatter().
    5. Добавление подписей к осям, заголовка графика, легенды и сетки для улучшения читаемости.
   Построение графика временного ряда:
    1. Загрузка данных о концентрации CO2 из пакета statsmodels.api в DataFrame pandas.
    2. Построение графика, используя индекс DataFrame (дата) как ось X и значения концентрации CO2 как ось Y с помощью функции plt.plot().
    3. Добавление подписей к осям, заголовка графика и сетки для улучшения читаемости.

В результате выполнения работы были построены:

1. Диаграмма рассеяния для набора данных "Iris", отображающая взаимосвязь между длиной и шириной чашелистика для различных классов ирисов 
2. График временного ряда, отображающий изменение концентрации CO2 в атмосфере в период с 1958 по 1980 год 


 Отчет по лабораторной работе 4 вариант 1 "Анализ данных в формате GenBank с использованием BioPython"

Цель работы:

Получить навыки работы с библиотекой BioPython для анализа нуклеотидных последовательностей, представленных в формате GenBank, включая расчет GC-состава и извлечение информации о трансляциях.

Задачи:

1.  Разработать функцию calculate_gc_content(sequence) для вычисления GC-состава нуклеотидной последовательности.
2.  Реализовать функцию analyze_gc_content(genbank_file) для анализа GC-состава записей в GenBank файле и вывода отсортированного списка записей по возрастанию GC-состава.
3.  Реализовать функцию analyze_translations(genbank_file) для анализа информации о трансляциях в GenBank файле и вывода ID записи, кодирующей последовательности (Coding sequence location) и аминокислотной последовательности (Translation).
4.  Продемонстрировать работу функций с объединенным GenBank файлом, содержащим нуклеотидные последовательности организма *Paralichthys dentatus*.

Инструменты, Алгоритмы:

Язык программирования: Python 3.x
Библиотека BioPython: Для работы с биологическими последовательностями, в частности для чтения файлов формата GenBank (SeqIO.parse).
Функция calculate_gc_content(sequence):
     Входные данные: Строка, представляющая нуклеотидную последовательность.
     Алгоритм:
        1.  Перевод последовательности в верхний регистр с помощью sequence.upper().
        2.  Подсчет количества символов 'G' и 'C' в последовательности с помощью метода count().
        3.  Расчет GC-состава как отношение суммы количеств 'G' и 'C' к общей длине последовательности, умноженное на 100.
    Выходные данные: Вещественное число, представляющее GC-состав последовательности в процентах.
 Функция analyze_gc_content(genbank_file):
     Входные данные: Строка, представляющая имя GenBank файла.
     Алгоритм:
        1.  Чтение GenBank файла с использованием SeqIO.parse(genbank_file, "genbank").
        2.  Для каждой записи в файле:
             Вычисление GC-состава с использованием функции calculate_gc_content().
             Добавление ID записи, GC-состава и самой последовательности в список records.
        3.  Сортировка списка records по возрастанию GC-состава с использованием функции sort() и лямбда-функции для указания ключа сортировки.
        4.  Вывод ID записи и GC-состава для каждой записи в отсортированном списке.
       Выходные данные: Список кортежей, содержащих ID записи, GC-состав и последовательность.
  Функция analyze_translations(genbank_file):
      Входные данные: Строка, представляющая имя GenBank файла.
       Алгоритм:
        1.  Чтение GenBank файла с использованием SeqIO.parse(genbank_file, "genbank").
        2.  Для каждой записи в файле:
             Итерация по feature в записи с использованием record.features.
             Проверка, является ли feature кодирующей последовательностью (CDS) и содержит ли qualifier "translation".
             Извлечение кодирующей последовательности (coding_sequence_location) и аминокислотной последовательности (translation).
             Добавление ID записи, coding_sequence_location и translation в список records_with_translations.
        3.  Вывод ID записи, coding_sequence_location и translation для каждой записи, содержащей информацию о трансляции.
       Выходные данные: Список кортежей, содержащих ID записи, coding_sequence_location и аминокислотную последовательность.

Ошибки и их исправления:

 Ошибка 1: Первоначально в коде отсутствовала проверка на наличие qualifier "translation" в feature CDS. В результате, при обработке записей, в которых CDS не содержала информации о трансляции, возникала ошибка KeyError.
    Исправление: Добавлена проверка if "translation" in feature.qualifiers: перед извлечением информации о трансляции.

   